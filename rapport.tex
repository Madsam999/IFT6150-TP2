\documentclass{article}
% --- General Packages ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{fullpage}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{url}
\usepackage{setspace}
\usepackage{comment}
\usepackage{xcolor}

% --- Math Packages ---
\usepackage{amsmath,amssymb,amsthm,nccmath}
\usepackage{amsfonts}
\usepackage{bm}

% --- Table & Figure Packages ---
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{float}

% --- Code & Text Packages ---
\usepackage{listings}
\usepackage[autostyle, english = american]{csquotes}
\usepackage{algpseudocode}
\usepackage{tikz}
\usepackage{subcaption}
\usetikzlibrary {automata,positioning}

% --- Listing Style Configuration ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\scriptsize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=1pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    inputencoding=utf8,
    extendedchars=true,
}
\lstset{style=mystyle,
    literate={«}{{\guillemotleft}}1{»}{{\guillemotright}}1{’}{{\textquoteright}}1
}
\setlength{\parindent}{0in}
\setlength{\parindent}{0in}
\begin{document}
\begin{titlepage}
	\begin{center}
		\vspace*{1cm}

		\Huge
		\textbf{Devoir 2}

		\vspace{0.5cm}
		\LARGE

		\vspace{1.5cm}

        
		\textbf{Samuel Fournier}\\20218212 \\
		\vfill
		\textbf{Alexandre Toutant}\\20028191 \\
		\vfill


		Dans le cadre du cours\\
		IFT 6150


		\vspace{0.8cm}

		\includegraphics[width=0.4\textwidth]{udem.jpg}

		\Large
		Département d'informatique et de recherche opérationnelle\\
		Université de Montréal\\
		Canada\\
		29 octobre 2025

	\end{center}
\end{titlepage}
\section{Introduction}

Ce travail pratique avait pour but de programmer, en langage C, les principales étapes du détecteur de contours de \textbf{Canny}.  
L'objectif était de comprendre comment on peut passer d'une image en niveaux de gris à une image contenant seulement les contours importants, tout en réduisant le bruit et les faux contours.

\subsection{But du TP}
Le but du TP était de réaliser un programme capable de détecter les contours d’une image.  
Pour y arriver, le programme effectue les étapes suivantes :
\begin{enumerate}
    \item Appliquer un \textbf{flou gaussien} pour réduire le bruit;
    \item Calculer le \textbf{gradient} d’intensité avec les filtres \((-1,1)\);
    \item Trouver la \textbf{direction du gradient} (0°, 45°, 90°, 135°);
    \item Faire la \textbf{suppression des non-maximums} pour amincir les contours;
    \item Appliquer un \textbf{double seuillage} (\(\tau_L\), \(\tau_H\)) avec un suivi par hystérésis pour ne garder que les vrais bords.
\end{enumerate}

\subsection{Rôle des contours}
Les contours représentent les zones où l’intensité change brusquement.  
Ils délimitent les objets et aident à comprendre la structure d’une image.  
La détection de contours est essentielle pour plusieurs applications : segmentation d’objets, reconnaissance de formes, suivi de mouvement, etc.  
Un bon détecteur doit être à la fois précis, résistant au bruit et produire des bords fins et continus.

\subsection{Filtre gaussien}
Avant la détection des contours, un \textbf{filtre gaussien} est appliqué pour adoucir l’image et éliminer le bruit.  
Cela empêche le détecteur de confondre les petites variations d’intensité avec de faux contours.  
Dans notre code, ce filtrage est effectué dans le \textbf{domaine fréquentiel} à l’aide de la \textbf{transformée de Fourier (FFT)}.  
Le paramètre \(\sigma\) contrôle l’intensité du flou :
\begin{itemize}
    \item petit \(\sigma\) : plus de détails visibles;
    \item grand \(\sigma\) : image plus lissée, moins de bruit.
\end{itemize}
Cette étape prépare l’image pour le calcul du gradient et assure une détection de contours plus stable.

\section{Description de la méthode utilisée pour calculer le gradient, la norme et l'angle}

Le calcul du gradient permet d’identifier les zones de l’image où l’intensité varie le plus rapidement, ce qui correspond aux contours.  
Dans notre programme, le gradient est obtenu à l’aide des filtres de convolution \([-1, 1]\), appliqués séparément sur les directions horizontales et verticales.

\subsection*{Calcul du gradient}
Pour chaque pixel, deux dérivées sont calculées :
\begin{itemize}
    \item \( G_x = I(x, y+1) - I(x, y) \) pour la variation horizontale;
    \item \( G_y = I(x+1, y) - I(x, y) \) pour la variation verticale.
\end{itemize}
Ces filtres simples permettent d’estimer la direction et l’intensité du changement local dans l’image.

\subsection*{Norme du gradient}
La norme du gradient indique l'intensité du contour à chaque point :
\[
G = \sqrt{G_x^2 + G_y^2}
\]
Plus la norme est grande, plus le contour est fort.  
C’est cette valeur qui est utilisée plus tard pour la suppression des non-maximums et pour l’hystérésis.

\subsection*{Angle du gradient}
L’orientation du gradient est donnée par :
\[
\theta = \arctan{\left(\frac{G_y}{G_x}\right)}
\]
Dans le programme, cet angle est converti en degrés et ramené dans l’intervalle \([0,180]\).  
Il est ensuite estimé selon quatre directions principales : 0°, 45°, 90° et 135°, ce qui simplifie la comparaison des pixels lors de la suppression des non-maximums.

\section{Dénombrer le nombre de seuils dans le filtre de Canny}

Le filtre de Canny utilise \textbf{deux seuils} : un seuil bas (\(\tau_L\)) et un seuil haut (\(\tau_H\)).  
Le seuil haut sert à détecter les contours forts, tandis que le seuil bas garde les contours plus faibles s’ils sont reliés à un contour fort.  
Les pixels sous \(\tau_L\) sont ignorés.  
Ce double seuillage permet de conserver des bords continus tout en réduisant les faux contours causés par le bruit.

\section{Description de la méthode utilisée pour calculer les seuils à partir de l'histogramme}
La méthode utilisée est une méthode d'histogramme simple. Juste avant la supression des non-maximums, on créé une liste de longueur $length \times width$ qui contient tous
les gradients de tous les pixels:
\begin{lstlisting}[language=c]
    float** gradList = fmatrix_allocate_1d(length * width);
\end{lstlisting}
Ensuite, on utilise un algorithme de trie très rudimentaire (et lent) pour trier les valeurs des gradient dans cette liste:
\begin{lstlisting}[language=C]
    int totalSize = length * width;
    float key;

    for (int i = 1; i < totalSize; i++) {
        key = sortedGrads[i]; 
        j = i - 1;

        while (j >= 0 && sortedGrads[j] > key) {
            sortedGrads[j + 1] = sortedGrads[j];
            j = j - 1;
        }
        sortedGrads[j + 1] = key; 
    }
\end{lstlisting}
Une fois la liste triée, on utilise la valeur de la variable $p\_H$ pour déterminer la valeur de $\tau_h$ et de $\tau_l$. Pour trouver la valeur de $\tau_h$ 
choisit le gradient se trouvant au $p\_H$ ième percentile de la liste. Par exemple, si on a que $p\_H = 0.9$, on choisit la valeur du gradient se trouvant à 
l'index qui se trouve à $90\%$ de la liste.
\begin{lstlisting}[language=C]
    int indexToCut = (int)floor((float)(length * width) * p_H);
    float tau_h = sortedGrads[indexToCut];
\end{lstlisting}
Finalement, pour obtenir $\tau_l$, on multiplie $\tau_h$ par $0.5$.
\begin{lstlisting}[language=C]
    float tau_l = 0.5 * tau_h;
\end{lstlisting}
Une fois les valeurs de $\tau_h$ et $\tau_l$ calculer, on continue l'algorithme comme normale en faisant la supression des non-maximums
et du seuillage par hystérisis. \\\\
Avec une valeur de $p_H$ de $0.9$, on obtient $\tau_h = 65.23$ et $\tau_l = 32.62$ (deux valeurs très proche du 66 et 33 utilisé lors de l'ancienne méthode). 
Avec ces valeurs, on obtient l'image suivante:
\begin{figure}[H]
    \center
    \includegraphics[scale=0.5]{TpIFT6150-2-canny_09.png}
    \caption{Résultat final avec $\sigma = 1$ et $p_H = 0.9$}
\end{figure}
Si on diminue la valeur de $p_H$ à 0.7, on observe que l'algorithme préserve beaucoup plus de contours qu'avant:
\begin{figure}[H]
    \center
    \includegraphics[scale=0.5]{TpIFT6150-2-canny_07.png}
    \caption{Résultat final avec $\sigma = 1$ et $p_H = 0.7$}
\end{figure}
Finalement avec une valeur de $p_H$ de $0.95$, on voit qu'il y a moins de contours de préservés:
\begin{figure}[H]
    \center
    \includegraphics[scale=0.5]{TpIFT6150-2-canny_095.png}
    \caption{Résultat final avec $\sigma = 1$ et $p_H = 0.95$}
\end{figure}

\section{Description de l’approximation de l’angle}

L’angle du gradient est calculé à l’aide de la fonction \(\arctan\left(\frac{G_y}{G_x}\right)\), ce qui donne une valeur comprise entre \(0\) et \(180\) degrés.  
Pour simplifier le traitement lors de la suppression des non-maximums, on ne garde pas l’angle exact.  
On retourne plutôt la valeur parmi \(0^\circ\), \(45^\circ\), \(90^\circ\) ou \(135^\circ\) qui est la plus proche de l’angle réel calculé.  
Cela permet de déterminer plus facilement la direction du contour sans perdre d’information importante.

\section{Description du but de la suppression des non-maximums dans le filtre de Canny}
Plusieurs gradients vont avoir des normes élevés, mais ce n'est pas tous ces gradient qui vont être pertinent au contour. Comme on le voit dans 
l'image avant la supression des non-maximus, les contours des formes sont larges et légèrement floues. L'objectif de la méthode
de supression des non-maximums est donc d'amincir le countour des objets de l'image. Pour exécuter cette méthode, on doit itérer sur tous les gradients de notre
image et déterminer si ce gradient est un maximum local ou non. Chaque gradient est associé à une direction qui est tangentielle au contour. Par conséquent,
on compare la force du gradient des deux voisions les plus proches du pixel (dans la direction tangentielle du gradient) et si la norme du gradient du pixel
en question est plus grande que celle de ses deux voisins, on le conserve (on laisse la couleur du pixel à 255), sinon on le supprime (on met la couleur
du pixel à 0). Une fois cette opération complétée, on peut faire un seuillage par hystérisis sur l'image pour conserver les gradients qui se trouvent 
dans une zone spécifique.
\section{Description du but du seuillage pas hystérisis dans le filtre de Canny}
Comme on l'a mentionné brièvement dans la section précédente, l'objectif du seuillage par hystérisis est d'éliminer les gradients qui ne se
retrouvent pas dans une certaines zones. Cette zone est délimiter par les variables $\tau_L$ et $\tau_H$. L'objectif de cette algorithme est relativement 
similaire à un algorithme de type \textit{flood fill}. Cependant, plutôt que de remplir une zone délimiter par un contour, on rempli les contours selon
l'intervalle $[\tau_L; \tau_H]$. On a choisit d'implémenter une méthode récursive et itérative. La méthode récursive est assez simple. Elle itère sur tous
les pixels d'une image noire de même taille que l'image initiale (après la supression des non-maximums) et si le gradient de ce pixel est supérieur à notre borne
supérieure, on commence la procédure récursive. Cette procédure va ensuite vérifier si ce pixel est un contour (pixel blanc) ou pas (pixel noir) et si
la norme du gardient du pixel se trouve par-dessus la borne inférieure. Si c'est le cas, on colorie ce pixel en blanc et on obtient l'orientation 
de ce pixel et on applique la même procédure récursive à ses deux voisins les plus proches.
\begin{lstlisting}[language=C]
    void follow(float** sups, int x, int y, float** orient, float** result, int width, int height, float tauL) {
    // If higher than lower bound and not a contour, then it becomes one

    if(sups[y][x] > tauL && result[y][x] == 0.f) {
        result[y][x] = 255.f;
        for(int i = 0; i < 4; i++) {
            int dir = (int)orient[y][x];
            switch (dir) {
            case 0:
                if(x - 1 >= 0) {
                    follow(sups, x - 1, y, orient, result, width, height, tauL);
                }
                else if(x + 1 < width) {
                    follow(sups, x + 1, y, orient, result, width, height, tauL);
                }
            case 45:
                if(x + 1 < width && y - 1 >= 0) {
                    follow(sups, x + 1, y - 1, orient, result, width, height, tauL);
                }
                else if(x - 1 >= 0 && y + 1 < height) {
                    follow(sups, x - 1, y + 1, orient, result, width, height, tauL);
                }
            case 90:
                if(y - 1 >= 0) {
                    follow(sups, x, y - 1, orient, result, width, height, tauL);
                }
                else if(y + 1 < height) {
                    follow(sups, x, y + 1, orient, result, width, height, tauL);
                }
            case 135:
                if(x - 1 >= 0 && y - 1 >= 0) {
                    follow(sups, x - 1, y - 1, orient, result, width, height, tauL);
                }
                else if(x + 1 < width && y + 1 < height) {
                    follow(sups, x + 1, y + 1, orient, result, width, height, tauL);
                }
            }
        }
    }
}

void recursiveHysteresis(float** result, float** sups, float** orient, int width, int height, float tauL, float tauH) {
    for(int y = 0; y < height; y++) {
        for(int x = 0; x < width; x++) {
            if(sups[y][x] > tauH) {
                follow(sups, x, y, orient, result, width, height, tauL);
            }
        }
    }
}
\end{lstlisting}
La méthode itérative utilise les principes d'une queue. On commence par touvé les pixels avec une norme de gradient supérieure $\tau_H$. Ensuite, on itère
sur cette liste en ajoutant les voisins de ce pixel et on colorie les pixels en blanc si leur norme est supérieure à $\tau_L$ et en noir sinon.
\begin{lstlisting}[language=C]
float** edges = fmatrix_allocate_2d(length, width);
for (i = 0; i < length; ++i)
    for (j = 0; j < width; ++j)
        edges[i][j] = 0.0f;

int maxq = length * width;
int *qY = (int*)malloc(sizeof(int)*maxq);
int *qX = (int*)malloc(sizeof(int)*maxq);
int head = 0, tail = 0;

for (i = 0; i < length; ++i) {
    for (j = 0; j < width; ++j) {
        if (nms_norm[i][j] > tau_H) {
            edges[i][j] = 255.0f;
            qY[tail] = i; qX[tail] = j; ++tail;
        }
    }
}

while (head < tail) {
    int y = qY[head], x = qX[head]; ++head;
    for (int dy8 = -1; dy8 <= 1; ++dy8) {
        for (int dx8 = -1; dx8 <= 1; ++dx8) {
            if (dy8 == 0 && dx8 == 0) continue;
            int ny = y + dy8, nx = x + dx8;
            if (ny < 0 || ny >= length || nx < 0 || nx >= width) continue;

            if (edges[ny][nx] == 0.0f && nms_norm[ny][nx] >= tau_L) {
                edges[ny][nx] = 255.0f;
                qY[tail] = ny; qX[tail] = nx; ++tail;
            }
        }
    }
}
\end{lstlisting}
\section{Présentation des résultats expérimentaux}
\section{Discussion et conclusion}

\end{document}